---

## 영속성 컨텍스트란?

**"엔티티를 영구적으로 저장하는 환경"**

( 보이지 않는 공간 ) 

- 엔티티의 생명 주기
    - 비영속 ( new / transient ) 영속성 컨텍스트와 관계가 X

        → 객체를 생성만 하고 영속성 컨텍스트에 넣지 X 

    - 영속 ( managed ) 영속성 컨텍스트에 의해 관리 됨

        → 비영속 상태인 객체를 persist를 통해 영속 상태로 만들어줌 ( DB 에 저장되는건 아님 )

    - 준영속 ( detached ) 관리가 되었다가 분리

        → em.detach(member) 영속상태에서 나오게함

    - 삭제 (remove)

---

## 영속성 컨텍스트의 이점

- 1차 캐시
- 동일성 보장
- 트랜잭션을 지원하는 쓰기지연
- 변경 감지 ( dirty checking )
- 지연 로딩 ( lazy loading )

 

---

 

### 1차 캐시

- 영속성 컨텍스트 안에 1차캐시 속에 persist 시 저장이 된다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e7bc687a-a69e-4ee0-9e23-87dad1376e90/_2021-06-01__8.20.32.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e7bc687a-a69e-4ee0-9e23-87dad1376e90/_2021-06-01__8.20.32.png)

- 이때 1차 캐시를 영속성 컨텍스트라고 이해해도 무방함.
- 조회 순서 DB 먼저가 아니고 1차 캐시를 먼저 조회 한다. 만약 1차 캐시 안에 해당 객체가 없다면 그때 DB 를 조회 한다. ⇒ 이때 DB 에서 조회 하더라도 1차캐시에 저장이 되고 조회가 이루어져 다음에 찾아볼때 이득이 된다.
- 하지만 트랜잭션 단위인 영속 컨텍스트는 트랜잭션이 끝나면 없어지므로 그렇게 성능면에서 이점이 큰건 아니다.

---

### 영속 엔티티의 동일성 보장

- 자바 컬렉션에서 가져왔을시 같은 레퍼런스의 객체를 꺼내면 == 비교시 true 값이 반환 되는 것 처럼 Jpa 도 같은 객체를 조회시 컬렉션과 같은 방식의 결과 값을 낸다. ( 1차 캐시 덕분에 가능 )

---

### 엔티티 틍록 트랜잭션을 지원하는 쓰기 지연

- persist = insert 쿼리문 발생 X ( commit 시 쿼리문 발생 )

    → 영속성 컨텍스트의 1차 캐시와 쓰기지연 sql 저장소로 들어가게 됨. ( 이때 객체를 분석해 sql문을 생성하기만 함)

---

### 엔티티 수정 변경 감지

- set 을 통해 상태를 변화 시켜도 persist 가 없더라도 commit 시 변경을 감지해 반영이 된다.

- 즉 update 코드가 필요가 없다.
- Jpa 는 커밋 시점에 엔티티와 스냅 샷을 비교 하게 된다. 이때 스냅샷은 최초시점의 값을 스냅샷을 떠놓고 비교를 하면서 차이가 생겼을시 업데이트 쿼리를 쓰기지연 sql 저장소에 저장

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f5ddaded-0029-47b2-ba48-f732965dc1f6/_2021-06-01__8.38.53.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f5ddaded-0029-47b2-ba48-f732965dc1f6/_2021-06-01__8.38.53.png)

---

## 플러시

- 영속성 컨텍스트의 변경 사항을 데이터 베이스에 반영

- 변경 감지
- 수정된 엔티티 쓰기 지연 sql저장소에 등록
- 쓰기지연 sql내에 저장되어있는 쿼리문을 토대로 데이터베이스에 적용

🖍 플러시는 영속성 컨텍스트를 비우는게 아님!