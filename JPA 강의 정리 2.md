# 다양한 연관관계 매핑

## 연관 관계 매핑시 고려 사항

* 다중성
* 단방향, 양방향
* 연관관계의 주인

** 다중성 **
	1.```@ManyToOne```
	2.```@OneToMany```
    3.```@OneToOne```
    4.```@ManyToMany``` 실무에서 사용 X
    
   각 각 대칭을 이룬다 -> ex) ```@ManyToOne``` - ```@OneToMany```
   
** 단방향, 양방향 **
* 테이블
	
    * 외래키 하나로 양방향 조인 가능
    * 방향이라는 개념이 모호함
* 객체
	
    * 참조용 필드가 있는 쪽으로만 참조 가능 
    ex) 멤버 -> 팀 (멤버에서 팀으로 가는 참조(레퍼런스)가 필요)
    * 한쪽만 참조시 단방향
    * 양쪽 서로 참조 = 양방향
    연관 관계 주인 = 외래키를 관리하는 참조
    주인 X = 조회만 가능
---

## 프록시 

> Member 조회시 Team 을 사용하지 않아도 Team 까지 조회 해야 할까?

* 굳이 사용하지 않는 테이블을 조회 하는것은 비효율적이다. -> 이를 막기위해 ```지연로딩, 프록시```가 존재

** 프록시 **

* ```em.find()``` vs ```em.getReference()```
	
    * em.find() = > 즉시 실제 Entity 를 조회한다
    * em.getReference() => DB 조회를 미루는 가짜 엔티티 객체 조회 (DB의 엔티티 값이 필요할 경우에 DB에 쿼리문을 날림 (프록시))
    
** 프록시 특징 **
* 실제 클래스를 상속 받아 사용한다 (하이버네이트 자체가 해줌)
* 실제 클래스랑 겉 모양이 똑같음
* 사용시 실제 객체인지 프록시인지 구분이 안됨
* 프록시 객체는 처음 사용시 한번만 초기화(초기화란 가짜 엔티티 객체가 진짜 엔티티객체와 매핑 되는것 = 가짜 엔티티 객체가 진짜 엔티티 객체가 되는것은 아님 그저 접근이 가능해질뿐)

** IF ** 
* 영속성 컨텍스트의 1차 캐시에 해당 엔티티가 존재하면 가짜 엔티티가 아닌 그 값을 반환함

---
## 지연 로딩



    
    